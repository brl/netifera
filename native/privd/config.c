#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>
#include <limits.h>
#include <fcntl.h>
#include "privd.h"

static void create_config_directory(const char *);
static int ask_auth_enabled();
static char *ask_password();
static void write_config(const char *, const char *);

void
generate_config(const char *username)
{
	if(getuid() != 0) {
		fprintf(stderr, "Configuration file must be generated by running this command as root\n");
		exit(EXIT_FAILURE);
	}

	struct passwd *pw = getpwnam(username);
	if(pw == NULL) {
		fprintf(stderr, "Could not locate user %s in password file\n", username);
		exit(EXIT_FAILURE);
	}
	if(pw->pw_dir == NULL) {
		fprintf(stderr, "Home directory does not exist for user %s\n", username);
		exit(EXIT_FAILURE);
	}

	char path_buffer[PATH_MAX + 1];
	if(snprintf(path_buffer, sizeof(path_buffer), "%s/.privd", pw->pw_dir) > sizeof(path_buffer)) {
		fprintf(stderr, "Overflow creating path to .privd directory\n");
		exit(EXIT_FAILURE);
	}

	create_config_directory(path_buffer);
	int auth_enabled = ask_auth_enabled();
	if(auth_enabled) {
		char *password = ask_password();
		char *salt = bcrypt_gensalt(12);
		char *hash = bcrypt(password, salt);
		write_config(path_buffer, hash);
	} else {
		write_config(path_buffer, "DISABLED");
	}
}

static void
create_config_directory(const char *path)
{
	if(mkdir(path, 0711) && errno != EEXIST) {
		fprintf(stderr, "Error creating configuration directory %s : %s\n", path, strerror(errno));
		exit(EXIT_FAILURE);
	}
}

static int
ask_auth_enabled()
{

	char answer_buffer[80];
	while(1) {
		printf("Do you want to enable password authentication (Y/N)? ");
		if(fgets(answer_buffer, sizeof(answer_buffer), stdin) == NULL) {
			fprintf(stderr, "exiting....\n");
			exit(EXIT_FAILURE);
		}
		char c = answer_buffer[0];
		if(c == 'y' || c == 'Y')
			return 1;
		if(c == 'n' || c == 'N')
			return 0;
		printf("Please enter either 'Y' or 'N'.\n");
	}
	return 0; // Compiler wants this
}

static char *
ask_password()
{
	char *p;
	char *password;
	while(1) {
		printf("Enter authentication password.\n");
		p = getpass("Password:");
		if(strlen(p) == 0) continue;
		password = strdup(p);
		printf("Enter again for verification.\n");
		p = getpass("Password:");
		if(strcmp(password, p) == 0)
			return password;

		printf("Passwords do not match.  Try again.\n");
		free(password);
	}
}

static void
write_config(const char *directory, const char *auth_hash)
{
	char auth_buffer[256];
	char path_buffer[PATH_MAX];
	int fd, n;

	if(snprintf(path_buffer, sizeof(path_buffer), "%s/config", directory) > sizeof(path_buffer)) {
		fprintf(stderr, "Path length overflow building path to configuration file\n");
		exit(EXIT_FAILURE);
	}
	if(snprintf(auth_buffer, sizeof(auth_buffer), "AUTH_HASH=%s\n", auth_hash) > sizeof(auth_buffer)) {
			fprintf(stderr, "Out of buffer space constructing AUTH_HASH line for configuration file.\n");
			exit(EXIT_FAILURE);
	}
	if((fd = open(path_buffer, O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW, 0400)) < 0) {
		fprintf(stderr, "Failed to open configuration file %s for writing : %s\n", path_buffer, strerror(errno));
		exit(EXIT_FAILURE);
	}

	if((n = write(fd, auth_buffer, strlen(auth_buffer))) < 0) {
		fprintf(stderr, "Error writing to configuration file %s : %s\n", path_buffer, strerror(errno));
		close(fd);
		exit(EXIT_FAILURE);
	}

	if(n != strlen(auth_buffer)) {
		fprintf(stderr, "Write to configuration file was truncated at %d bytes\n", n);
		unlink(path_buffer);
		exit(EXIT_FAILURE);
	}

	close(fd);
}
